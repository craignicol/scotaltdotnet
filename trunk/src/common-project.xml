<?xml version="1.0" ?>
<project name="ncontinuity2" xmlns="http://nant.sf.net/release/0.85/nant.xsd">
	<include buildfile="common.xml" />

	<target name="common.build">

		<nant>
			<buildfiles refid="buildfiles.all" />
		</nant>

	</target>

	<target name="common.compile-tests"
		description="Compile NUnit tests and copy App.config file to the output directory, if it exists.">

		<property name="istestsproject" value="true" />
		<call target="common.compile-dll" />

		<property name="windsor.boo.file.src" value="${root.dir}/${project::get-name()}/Windsor.boo"/>
		<if test="${file::exists(windsor.boo.file.src)}">
			<copy
				file="${windsor.boo.file.src}"
				tofile="${build.dir}/Windsor.boo"
				overwrite="true"
				failonerror="true"
			/>
		</if>
		
		<!-- Check if there is a framework specific config file and use that -->
		<property name="app.config.src" value="${src.dir}/App-${framework::get-target-framework()}.config" />
		<if test="${file::exists(app.config.src)}">
			<copy
				file="${app.config.src}"
				tofile="${build.dir}/${project::get-name()}.dll.config"
			/>

			<call target="common.configure-tests" />
			<property name="app.config.src.found" value="true" />
		</if>
		
		<!-- In case there was no framework specific config check if there is a framework neutral file and use that. -->
		<property name="app.config.src" value="${src.dir}/App.config" />
		<if test="${file::exists(app.config.src)}" unless="${property::exists('app.config.src.found')}">
			<copy
				file="${app.config.src}"
				tofile="${build.dir}/${project::get-name()}.dll.config"
			/>

			<call target="common.configure-tests" />
		</if>
		<property name="connectionstring" value="${ar.connection.connection_string.2}"/>
		<echo message="${connectionstring}"/>
		<property name="booFile" value="${build.dir}/Windsor.boo" overwrite="true" readonly="false"/>
		<if test="${file::exists(booFile)}">
			<call target="fixBoo"/>
		</if>
	</target>

	<target name="common.configure-tests"
		description="Configure tests for running NUnit tests.">

		<property name="app.config" value="${build.dir}/${project::get-name()}.dll.config" />

		<!-- make sure the config file is writable -->
		<attrib file="${app.config}" readonly="false" />
	
	</target>

	<target name="common.compile-dll"
		description="Compile sources into a DLL">

		<property name="istestsproject" value="false"/>

		<echo message="build.msbuild = ${build.msbuild}"/>
		<if test="${build.msbuild}">
			<property name="msbuildlogger" value="" unless="${property::exists('CCNetLabel')}" />
			<property name="msbuildlogger" value="/logger:ThoughtWorks.CruiseControl.MsBuild.XmlLogger" if="${property::exists('CCNetLabel')}" />
			<property name="msbuild.defines" value="${string::replace(current.build.defines, ',', ';')}" />

			<exec program="${framework::get-framework-directory(framework::get-target-framework())}/MSBuild.exe" workingdir="${build.dir}">
				<arg file="&quot;${src.dir}/${project.vsproj}&quot;" />
				<arg value="/p:Configuration=${project.config}" />
				<arg value="/p:OutputPath=&quot;${build.dir}&quot;" />
				<arg value="/p:TreatWarningsAsErrors=${build.warnaserrors}" unless="${istestsproject}" />
				<arg value='/p:DefineConstants="${msbuild.defines}"' />
				<arg value='/t:Rebuild' if="${build.rebuild}" />
				<arg value="/p:DocumentationFile=${build.dir}/${project::get-name()}.xml" unless="${istestsproject}" />
				<arg value="/p:NoWarn=1591" unless="${build.warnmissingdocs}" />
				<arg line="/p:SignAssembly=${assembly.sign} /p:AssemblyOriginatorKeyFile=${key.file}" />
				<!--<arg value="${msbuildlogger}" />-->
			</exec>
		</if>

		<if test="${not build.msbuild}">
			<property name="warnaserror" value="false" if="${istestsproject}" />
			<property name="warnaserror" value="${build.warnaserrors}" if="${not istestsproject}" />
			<csc
				target="library"
				define="${current.build.defines}"
				debug="${build.debug}"
				optimize="${build.optimize}"
				warnaserror="${warnaserror}"
				output="${build.dir}/${project::get-name()}.dll"
				doc="${build.dir}/${project::get-name()}.xml"
				rebuild="${build.rebuild}"
				unless="${build.msbuild}" verbose="true"
			>
				<nowarn>
					<warning number="1591" unless="${build.warnmissingdocs}" />
					<!-- No XML comment for publicly visible member -->
				</nowarn>
				<sources refid="project.sources" />
				<references refid="project.references" />
				<resources refid="project.resources" />
				<arg line="${csc.keyfile}" if="${assembly.sign}" />
				<arg line="${csc.args}" />
			</csc>
		</if>
	</target>

	<target name="common.compile-website">
		<property name="bin.dir" value="${src.dir}/bin" />
		<mkdir dir="${bin.dir}" />
		<delete file="${bin.dir}/${project::get-name()}.pdb" failonerror="false" />
		<!-- To prevent 1.1 compiler from crashing when switching from a 2.0 build -->
		<property name="build.dir" value="${bin.dir}" />

		<call target="common.compile-dll" />
		<call target="common.copy-references" />
	</target>

	<target name="common.copy-references">
		<foreach item="File" property="reference">
			<in>
				<items refid="project.references" />
			</in>
			<do>
				<copy file="${reference}" todir="${bin.dir}" overwrite="${build.rebuild}" />
			</do>
		</foreach>
	</target>

	<target name="common.compile-exe"
		description="Compile sources into a console executable">

		<csc
			target="exe"
			define="${current.build.defines}"
			debug="${build.debug}"
			optimize="${build.optimize}"
			warnaserror="${build.warnaserrors}"
			output="${build.dir}/${project::get-name()}.exe"
		>
			<nowarn>
				<warning number="1591" unless="${build.warnmissingdocs}" />
				<!-- No XML comment for publicly visible member -->
			</nowarn>
			<sources refid="project.sources" />
			<references refid="project.references" />
			<resources refid="project.resources" />
			<arg line="${csc.keyfile}" if="${assembly.sign}" />
			<arg line="${csc.args}" />
		</csc>
	</target>

	<target name="common.set-assembly-attribute-values">
		<property name="assembly.is-cls-compliant" value="false" />
		<property name="assembly.is-com-visible" value="false" />
		<property name="assembly.guid" value="" />
		<property name="assembly.allow-partially-trusted-callers" value="false" />
		<property name="assembly.description" value="" />
		<property name="assembly.product" value="${project::get-name()}" />
		<property name="assembly.company" value="${project.company}" />
		<property name="assembly.title" value="${project::get-name()} for ${framework::get-description(framework::get-target-framework())}" />
		<property name="assembly.version" value="${project.major}.${project.minor}.${project.build}.0" />
		<property name="assembly.version.informational" value="${assembly.major}.${assembly.minor}.${assembly.build}.${svn.revision}" />
		<property name="assembly.copyright" value="ncontinuity2 Project, original author or authors" />
		<property name="assembly.keyfile" value="${key.file}" />
		<property name="assembly.sign" value="${sign}" />
	</target>

	<target name="common.generate-assemblyinfo"
		depends="common.init common.set-assembly-attribute-values"
		description="Generate AssemblyInfo.cs using assembly.* properties.">
		<property name="assemblyinfo.cs" value="${path::combine(src.dir,'AssemblyInfo.cs')}" />
		<attrib file="${assemblyinfo.cs}" readonly="false" />
		<asminfo output="${assemblyinfo.cs}" language="CSharp">
			<imports>
				<import namespace="System" />
				<import namespace="System.Reflection" />
				<import namespace="System.Runtime.CompilerServices" />
				<import namespace="System.Runtime.InteropServices" />
				<import namespace="System.Security" if="${assembly.allow-partially-trusted-callers}" />
			</imports>
			<attributes>
				<attribute type="CLSCompliantAttribute" value="${assembly.is-cls-compliant}" />
				<attribute type="ComVisibleAttribute" value="${assembly.is-com-visible}" />
				<attribute type="GuidAttribute" value="${assembly.guid}" if="${assembly.guid != ''}" />
				<attribute type="AssemblyTitleAttribute" value="${assembly.title}" />
				<attribute type="AssemblyDescriptionAttribute" value="${assembly.description}" />
				<attribute type="AssemblyCompanyAttribute" value="${assembly.company}" />
				<attribute type="AssemblyProductAttribute" value="${assembly.product}" />
				<attribute type="AssemblyCopyrightAttribute" value="${assembly.copyright}" />
				<attribute type="AssemblyVersionAttribute" value="${assembly.version}" />
				<attribute type="AssemblyInformationalVersionAttribute" value="${assembly.version.informational}" />
				<attribute type="AssemblyFileVersionAttribute" value="${assembly.version.informational}" />
				<attribute type="AssemblyDelaySignAttribute" value="false" />

				<!-- For some reason, NAnt doesn't detect that APTCA has a public no-argument constructor -->
				<attribute asis="true" type="AllowPartiallyTrustedCallersAttribute" if="${assembly.allow-partially-trusted-callers}" />
			</attributes>
		</asminfo>
		<if test="${assembly.sign and not (nant.settings.currentframework == 'net-2.0')}" >
			<echo append="true" file="${assemblyinfo.cs}">#if MONO</echo>
			<echo append="true" file="${assemblyinfo.cs}">[assembly: AssemblyKeyFileAttribute(@"${path::get-full-path(assembly.keyfile)}")]</echo>
			<echo append="true" file="${assemblyinfo.cs}">#endif</echo> 
		</if>
	</target>

	<target name="common.assemblyinfo">

		<nant target="generate-assemblyinfo">
			<buildfiles refid="buildfiles.all" />
		</nant>
	</target>

	<target name="common.run-tests"
		description="Run NUnit tests">
		<property name="app.config" value="${build.dir}/${project::get-name()}.dll.config" />

		<if test="${common.testrunner.enabled}">

			<echo message="Running tests in '${project::get-name()}'" />
			
			<property name="xunit-console" value="${root.dir}../../lib/xunit.console.exe" overwrite="true" />
      
      <echo message="builddir = "/>
			<exec
				program="${xunit-console}"
				workingdir="${build.dir}"
				commandline="${project::get-name()}.dll ${build.dir}/${project::get-name()}.dll.config /nunit ${testresults.dir}/${project::get-name()}.dll-results.xml"
				failonerror="${common.testrunner.failonerror}"
			/>
      
		</if>
		<if test="${not common.testrunner.enabled}">
			<echo message="Tests are disabled for '${project::get-name()}'" />
		</if>

	</target>

	<target name="common.run-database-tests"
		depends="common.put-connection-settings-into-app-config common.run-tests common.remove-connection-settings-from-app-config" />

	<target name="common.put-connection-settings-into-app-config">

		<property name="app.config" value="${build.dir}/${project::get-name()}.dll.config" />

		<!-- make sure the config file is writable -->
		<attrib file="${app.config}" readonly="false" />

		<!-- 
			Tell nhibernate how to connect to the test database.
		-->
		<xmlpoke
			file="${app.config}"
			xpath="/configuration/nhibernate/add[@key='hibernate.dialect']/@value"
			value="${nhibernate.dialect}"
		/>
		<xmlpoke
			file="${app.config}"
			xpath="/configuration/nhibernate/add[@key='hibernate.connection.driver_class']/@value"
			value="${nhibernate.connection.driver_class}"
		/>
		<xmlpoke
			file="${app.config}"
			xpath="/configuration/nhibernate/add[@key='hibernate.connection.connection_string']/@value"
			value="${nhibernate.connection.connection_string}"
		/>
	</target>

	<target name="common.remove-connection-settings-from-app-config">
		<property name="app.config" value="${build.dir}/${project::get-name()}.dll.config" />

		<xmlpoke
			file="${app.config}"
			xpath="/configuration/nhibernate/add[@key='hibernate.connection.connection_string']/@value"
			value="conn string here"
		/>
	</target>

	<target name="fixBoo">
		<echo message="fixing bool file.........." />
		<echo message="${booFile}"/>
		<property name="find1" value="Server=[\w\-]*;Database=ncontinuity2;UID=[\w]*;pwd=[\w]*;"/>
		<property name="replace1" value="${connectionstring}"/>
		<property name="find2" value="Host = '[\w]*'"/>
		<property name="replace2" value="Host = '${emailServer.1}'"/>
		<script language="C#">
			<imports>
				<import namespace="System.Text.RegularExpressions"/>
				<import namespace="System.IO"/>
			</imports>
			<code>
				<![CDATA[
				public static void ScriptMain(Project project) {
					StreamReader reader = File.OpenText(project.Properties["booFile"]);
					string file = String.Empty;
					try {
						Regex expression1 = new Regex(project.Properties["find1"]);
						file = reader.ReadToEnd();
						file = expression1.Replace(file, project.Properties["replace1"]);
						Regex expression2 = new Regex(project.Properties["find2"]);
						file = expression2.Replace(file, project.Properties["replace2"]);
					} finally {
						// must remember to close the file or the compile may not work
						reader.Close();
					}
					// create a writer and open the file
					TextWriter tw = new StreamWriter(project.Properties["booFile"]);//${filename});
					try {
						// write a line of text to the file
						tw.WriteLine(file);
					} finally {
						// close the stream
						tw.Close();
					}
				}
					]]>
			</code>
		</script>
	</target>		
	
</project>
