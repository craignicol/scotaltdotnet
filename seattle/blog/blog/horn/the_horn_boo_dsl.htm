In my previous <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/purpose-of-horn-dsl.html">post</a>, I explained the purpose of the horn DSL.  In the <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/horn-package-manager-introduction.html">introduction</a> I mentioned that the open source project named horn that I contribute to is based on the <a target="_blank" href="http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=2&chap=1">gentoo portage</a> package management system.  At the heart of both portage and indeed <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> is the metaphor of the package tree. The package tree is conceptually a tree that contains leaves of package build instructions. In reality it is a directory structure that contains Dsl instance files of package build instructions.

In another previous <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/decision-to-use-booas-horn-internal-dsl.html">post</a>, I listed the reasons why <a target="_blank" href="http://boo.codehaus.org/">boo</a> was chosen as the language to host the internal Dsl.

The Dsl contains the build metadata that is required by <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> in order to both retrieve an open source project from a remote soure control management system and details of how to build or compile the components.

I mentioned in the previous <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/purpose-of-horn-dsl.html">post</a> that the purpose of the DSL is to create the in-memory domain model or <a href="http://martinfowler.com/dslwip/SemanticModel.html">semantic model</a> that <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> uses to retrieve and build open source software packages.

Below is the horn.boo file that tells the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> software system how to retrieve and build itself:
<div style="font-family: Courier New; color: black; background: white;">
<pre style="margin: 0px;">install horn:
&nbsp;&nbsp;&nbsp;&nbsp;description "A .NET build and dependency manager"
&nbsp;&nbsp;&nbsp;&nbsp;get_from svn("http://scotaltdotnet.googlecode.com/svn/trunk/")
&nbsp;&nbsp;&nbsp;&nbsp;build_with msbuild, buildfile("src/horn.sln"), FrameworkVersion35
&nbsp;&nbsp;&nbsp;&nbsp;output "Output"
&nbsp;&nbsp;&nbsp;&nbsp;shared_library "."
	                
dependencies:
&nbsp;&nbsp;&nbsp;&nbsp;depend @log4net >> "lib"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.core"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "Castle.DynamicProxy2"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.microKernel"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.windsor"</pre>
</div>
We like to think we are dog fooding by providing a build script for <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> but others may differ.  I am hoping that we did achieve our goal of constructing a semi English like prose of build instructions but I will have to leave that judgement to the interpretation of the reader, if you think it could be improved then please leave a comment.

I mentioned in the previous <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/purpose-of-horn-dsl.html">post</a> that when <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> receives a command line instruction such as <strong>horn -install:horn</strong> that <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> will search through the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> package tree or directory structure of build files until it finds the requested package's build file.  In this case the DSL script outlined above. 

The main engine of <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> or the core as it is known is a .NET assembly written in C#.  We also have a thin client .NET console application also written in C# that accepts command line instructions before passing them onto the core for execution.  The code to retrieve and search the package tree for the requested build file is non-interesting and standard so we will not mention it.  Suffice to say that it retrieves the correct build file before parsing it.  We will now take time to explain how we go about parsing a <a target="_blank" href="http://boo.codehaus.org/">boo</a> build file.

I must mention at this point that if I had not read <a target="_blank" href="http://ayende.com/blog/">Ayende</a>'s excellent book <a target="_blank" href="http://www.manning.com/rahien/">creating domain specific languages in boo</a> then I do not think I would have been able to use <a target="_blank" href="http://boo.codehaus.org/">boo</a> as our host language of choice for the DSL.  This book really is the best reference guide out there and trust me, I have looked.

One thing to bear in mind when writing a DSL in <a target="_blank" href="http://boo.codehaus.org/">boo</a> when compared to a more typical internal host language choice like python or ruby is that we do not have an interpeter to parse our scripts.  The DSL is compiled down to IL before it is executed.  Boo has an extensible compiler architecture that allows us to create a more palatable Dsl.

The very basic structure of the Boo compiler is the pipeline; it is how the compiler transforms bits of text in a file into executable code.  The <a target="_blank" href="http://boo.codehaus.org/">boo</a> language allows you, the user to plug your own steps into the compiler pipeline.  This allows you to add to the syntax of the language, just like the language designers did in C# 3.0 by adding query expressions. A compiler step can interact with the parsed code and change the abstract syntax tree.  New pipelines and steps can be defined at will. The compiler pipeline is a collection of loosely coupled objects each with their own task to complete. 

The technique we have chosen for <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> is to create what is known as an <i>anonymous base class</i> that is the basis of our Dsl.  The anonymous base class is a standard approach for building a Dsl in <a target="_blank" href="http://boo.codehaus.org/">boo</a>.  It is composed of a base class in our application code, and a compiler step in <a target="_blank" href="http://boo.codehaus.org/">boo</a> that will turn the Dsl script into a class that is derived from the defined base class.  It is known as an anonymous base class because there is no mention of the base class in the Dsl script. If you look at the horn.boo dsl script at the top of the page you can think of the keywords <strong><i>install</i></strong>, <strong><i>description</i></strong>, <strong><i>get_from</i></strong> etc. as methods on the base class that we are simply calling in our script.

Below is a code snippet of the basic outline of the BooConfigReader anonymous base class we have defined in the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> application code to act as a base class for our Dsl scripts:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;"><span style="color: blue;">public</span> <span style="color: blue;">abstract</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">BooConfigReader</span>
{
&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Meta</span>]
&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">static</span> <span style="color: #2b91af;">Expression</span> install(<span style="color: #2b91af;">ReferenceExpression</span> expression, <span style="color: #2b91af;">Expression</span> action)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> installName = <span style="color: blue;">new</span> <span style="color: #2b91af;">StringLiteralExpression</span>(expression.Name);
&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">MethodInvocationExpression</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">ReferenceExpression</span>(<span style="color: #a31515;">"GetInstallerMeta"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; installName,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; action
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> description(<span style="color: blue;">string</span> text)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Description = text;
&nbsp;&nbsp;&nbsp; }</pre>
</div>
Dsl script instances will inherit from this inherit from this class.  Below is the first two lines of the horn.boo Dsl build script:
<div style="font-family: Courier New; color: black; background: white;">
<pre style="margin: 0px;">install horn:
&nbsp;&nbsp;&nbsp;&nbsp;description "A .NET build and dependency manager"</pre>
</div>
You can see that we have methods in the base classes that correspond to methods in the Dsl Script.  We will explain how this works in the next post.

And below is a code snippet of the same class written in <a target="_blank" href="http://boo.codehaus.org/">boo</a>:
<div style="font-family: Courier New; color: black; background: white;">
<pre style="margin: 0px;">abstract class BooConfigReader(IQuackFu): 
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;[Meta]
&nbsp;&nbsp;&nbsp;&nbsp;static def install(expression as ReferenceExpression, action as Expression):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = StringLiteralExpression(expression.Name)
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.GetInstallerMeta($name, $action)
&nbsp;&nbsp;&nbsp;&nbsp;|]	                
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;depend @log4net >> "lib"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.core"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "Castle.DynamicProxy2"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.microKernel"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.windsor"</pre>
</div>

It is at this point that I will introduce the excellent Rhino.Dsl library.  I gave a mention earlier to <a target="_blank" href="http://ayende.com/blog/">Ayende</a> who is the creator and probably the main contributor to the <a target="_blank" href="http://sourceforge.net/projects/rhino-tools/">Rhino Tools</a> open source project.  I use many of these tools in my day job so it came as no suprise to discover that there is a <strong>Rhino.Dsl</strong> project that contains components that provide labour intensive functionality for building and running DSLs written in <a target="_blank" href="http://boo.codehaus.org/">boo</a>.

The Rhino.Dsl library provides a number of classes that will take care of a lot of the heavy lifting for the common Dsl tasks that we would otherwise have to code in <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> ourselves.  Examples of such tasks are parsing the Dsl files and shielding us from the repetitive boiler plate code that is need to add an anonymous base class to the <a target="_blank" href="http://boo.codehaus.org/">boo</a> compiler pipeline.

Let us examine the following code that uses 2 such Rhino.Dsl classes:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">var factory = <span style="color: blue;">new</span> <span style="color: #2b91af;">DslFactory</span>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BaseDirectory = packageTree.CurrentDirectory.FullName
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; };
&nbsp;
factory.Register&lt;<span style="color: #2b91af;">BooConfigReader</span>&gt;(<span style="color: blue;">new</span> <span style="color: #2b91af;">ConfigReaderEngine</span>());</pre>
</div>
In the above code we are creating an instance of the Rhino.Dsl.DslFactory and telling it to load all the build scripts in a specific folder.  

We then have the following line:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">factory.Register&lt;<span style="color: #2b91af;">BooConfigReader</span>&gt;(<span style="color: blue;">new</span> <span style="color: #2b91af;">ConfigReaderEngine</span>());</pre>
</div>
The Register method of the DslFactory allows us to register instances of another Rhino.Dsl class named DslEngine or as in the case above with the ConfigReaderEngine, classes that derive from DslEngine.  The DslEngine class abstracts away a lot of the boiler plate code that is required to compile instances of Dsl scripts.  The DslEngine contains a number of extension points.  One of these extension points is a method called <i>CustomizeCompiler</i>.  This method allows us to customise the Compiler pipeline.  We mentioned earlier that the main mechanics for the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> Dsl was to create an anonymous base class and register it in the <a target="_blank" href="http://boo.codehaus.org/">boo</a> compiler pipeline.  We are passing in the type of anonymous base class a generic argument in the base class.

As mentioned earlier, the Rhino.Dsl.Engine class provides extension points for <a target="_blank" href="http://boo.codehaus.org/">boo</a> compiler pipeline extensibility.  The point of extension we use in <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> is the CustomizeCompiler method.  Below is the code listing for ConfigReader class that inherits from DslEngine and we use in <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> to add our own compiler modifications and that we registered in the DslFactory in the previous code listing.
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;"><span style="color: blue;">public</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">ConfigReaderEngine</span> : <span style="color: #2b91af;">DslEngine</span>
{
&nbsp;&nbsp;&nbsp; <span style="color: blue;">protected</span> <span style="color: blue;">override</span> <span style="color: blue;">void</span> CustomizeCompiler(<span style="color: #2b91af;">BooCompiler</span> compiler, <span style="color: #2b91af;">CompilerPipeline</span> pipeline, <span style="color: blue;">string</span>[] urls)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pipeline.Insert(1, <span style="color: blue;">new</span> <span style="color: #2b91af;">ImplicitBaseClassCompilerStep</span>(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">BooConfigReader</span>), <span style="color: #a31515;">"Prepare"</span>, <span style="color: #a31515;">"Horn.Core.Dsl"</span>));
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pipeline.InsertBefore(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">ProcessMethodBodiesWithDuckTyping</span>), <span style="color: blue;">new</span> <span style="color: #2b91af;">RightShiftToMethodCompilerStep</span>());
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pipeline.Insert(2, <span style="color: blue;">new</span> <span style="color: #2b91af;">UnderscorNamingConventionsToPascalCaseCompilerStep</span>());
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pipeline.Insert(3, <span style="color: blue;">new</span> <span style="color: #2b91af;">UseSymbolsStep</span>());&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }
}</pre>
</div>
The code above is showing how we can add our own custom steps into the compiler pipeline.

Main line of code to observe in the above example is the following:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">pipeline.Insert(1, <span style="color: blue;">new</span> <span style="color: #2b91af;">ImplicitBaseClassCompilerStep</span>(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">BooConfigReader</span>), <span style="color: #a31515;">"Prepare"</span>, <span style="color: #a31515;">"Horn.Core.Dsl"</span>));</pre>
</div>
This takes care of adding our anonymous base class to the pipeline which will mean that every build script we parse will inherit from this class.  We use another Rhino class named ImplicitBaseClassCompilerStep that will again hide us from a lot of the <a target="_blank" href="http://boo.codehaus.org/">boo</a> infrastructure code to register an anonymous base class.

In <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> we register the anonymous base class compiler class and we add another compiler step with the code below:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">pipeline.InsertBefore(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">ProcessMethodBodiesWithDuckTyping</span>), <span style="color: blue;">new</span> <span style="color: #2b91af;">RightShiftToMethodCompilerStep</span>());</pre>
</div>
This allows us to transform the <strong><i>>></i></strong> bitwise operators in the dependencies section of the Dsl into something else:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">dependencies:
	depend @log4net >> "lib"</pre>
</div>
We will cover that in a future post.

Below is the code listing for how we get the DslFactory and DslEngine instances to work together to parse the Dsl script into our semantic model:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">configReader = factory.Create&lt;<span style="color: #2b91af;">BooConfigReader</span>&gt;(buildFilePath);
&nbsp;
configReader.Prepare();</pre>
</div>
We call the Create method of the factory passing in the path to the Dsl script and the type of anonymous base as a generic argument.  The prepare method is an abstract method on the anonymous base class.  When we call this method, the Dsl Script is invoked which will in turn call methods or functionality on the anonymouse base class that is now the base class of the Dsl script.

Thanks to Rhino.Dsl, we can concentrate on authoring our Dsl and let it take care of the boiler plate <a target="_blank" href="http://boo.codehaus.org/">boo</a> plumbing code.

In the next post we will go line for line through the Dsl Script syntax to see how we achieved the result.

In the next post, we will get describe how the build script syntax was achieved.

If any of this is of interest to you then please join the <a target="_blank" href="http://groups.google.co.uk/group/horn-development?hl=en">Horn user group</a> for updates or check out the source <a href="http://code.google.com/p/scotaltdotnet/">here</a>.

