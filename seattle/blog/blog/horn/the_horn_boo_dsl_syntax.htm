In a previous <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/parsing-horn-dsl.html">post</a> , I outined how horn build scripts where retrieved from the file system and compiled down into IL with the help of some wrapper or facade classes defined in the excellent Rhino.Dsl class.

I also mentioned that the technique used is to create what is known as an anonymous base class that is inserted into the boo compiler pipeline.  This anonymous base class becomes the base class for the Dsl build script Dsl instances.  The anonymous base class exists in the horn application code.

First up let us look at a Dsl build script instance.  The code below is the Dsl script used to describe the metadata that is required to build horn:
<div style="font-family: Courier New; color: black; background: white;">
<pre style="margin: 0px;">install horn:
&nbsp;&nbsp;&nbsp;&nbsp;description "A .NET build and dependency manager"
&nbsp;&nbsp;&nbsp;&nbsp;get_from svn("http://scotaltdotnet.googlecode.com/svn/trunk/")
&nbsp;&nbsp;&nbsp;&nbsp;build_with msbuild, buildfile("src/horn.sln"), FrameworkVersion35
&nbsp;&nbsp;&nbsp;&nbsp;output "Output"
&nbsp;&nbsp;&nbsp;&nbsp;shared_library "."
	                
dependencies:
&nbsp;&nbsp;&nbsp;&nbsp;depend @log4net >> "lib"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.core"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "Castle.DynamicProxy2"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.microKernel"
&nbsp;&nbsp;&nbsp;&nbsp;depend @castle  >> "castle.windsor"</pre>
</div>
As we mentioned previously, the build script listed above is effectively a derived class of the BooConfigReader class that we have inserted into the boo compiler pipeline with the following code:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">var factory = <span style="color: blue;">new</span> <span style="color: #2b91af;">DslFactory</span>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BaseDirectory = packageTree.CurrentDirectory.FullName
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; };
&nbsp;
factory.Register&lt;<span style="color: #2b91af;">BooConfigReader</span>&gt;(<span style="color: blue;">new</span> <span style="color: #2b91af;">ConfigReaderEngine</span>());</pre>
</div>
Below is a code snippet of the basic outline of the BooConfigReader anonymous base class we have defined in the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> application code to act as a base class for our Dsl scripts:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;"><span style="color: blue;">public</span> <span style="color: blue;">abstract</span> <span style="color: blue;">class</span> <span style="color: #2b91af;">BooConfigReader</span>
{
&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Meta</span>]
&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">static</span> <span style="color: #2b91af;">Expression</span> install(<span style="color: #2b91af;">ReferenceExpression</span> expression, <span style="color: #2b91af;">BlockExpression</span> action)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> installName = <span style="color: blue;">new</span> <span style="color: #2b91af;">StringLiteralExpression</span>(expression.Name);
&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">MethodInvocationExpression</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">ReferenceExpression</span>(<span style="color: #a31515;">"GetInstallerMeta"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; installName,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; action
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> <span style="color: blue;">void</span> description(<span style="color: blue;">string</span> text)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Description = text;
&nbsp;&nbsp;&nbsp; }</pre>
</div>
I will list code in both C# and boo for the BooConfigReader anonymous base class that will illustrate how we parse the code from Dsl script into our semantic or domain model which horn will use to build the required component.

Let us start at line 1 as that is a very good place to start:
<div style="font-family: Courier New; color: black; background: white;">
<pre style="margin: 0px;">install horn:</pre>
</div>
We have several extension points in boo when it comes to extending the language, from compiler steps to meta-methods, from AST attributes to AST macros.  This means you can write extensions in the compiler when the boo code compiles.  

One of these techniques is what is known in boo speak as a meta-method.  A meta-method is a short cut to the compiler that accepts an AST node and returns an AST node.

It is important to comprehend what an AST node is.  One of the steps in the boo compiler pipeline is known as the parsing stage which parses the source code stream into an <a target="_blank" href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>.  Subtrees or AST nodes will be passed to compiler extension points such as meta-methods or macros during compilation.

Meta-methods must be static and marked with the MetaAttribute for the compiler to recognise them as so.  The BooConfigReader contains a meta-method named install that will take the AST node <strong>install horn:</strong> and transform it into an instance method of the BooConfigReader class.  Because boo supports parenthisis-less method invocations we can call the install method as is listed above or it could be called with the parenthis <strong>install(horn)</strong>.

Below is the C# listing of the install meta-method:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">[<span style="color: #2b91af;">Meta</span>]
<span style="color: blue;">public</span> <span style="color: blue;">static</span> <span style="color: #2b91af;">Expression</span> install(<span style="color: #2b91af;">ReferenceExpression</span> expression, <span style="color: #2b91af;">BlockExpression</span> action)
{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> installName = <span style="color: blue;">new</span> <span style="color: #2b91af;">StringLiteralExpression</span>(expression.Name);
&nbsp;
&nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">MethodInvocationExpression</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">ReferenceExpression</span>(<span style="color: #a31515;">"GetInstallerMeta"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; installName,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; action
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );
}</pre>
</div>
It is important to remember that the meta-method is invoked at compile time. When the compiler sees the call to the <strong>install</strong> meta-method during compilation of the Dsl script, it does'nt emit the code to call the method at runtime.  Instead during compilation the meta-method is executed.  Passed to the install meta-method is an AST of the arguments of the method code, the first being the <strong><i>horn</i></strong> part of the <strong><i>install horn:</i></strong> expression.  The second being the <strong><i>anonymous block</i></strong> which is everything after the colon and is scoped by indentation.  The code below is the anonyomous block.  
<div style="font-family: Courier New; color: black; background: white;">
&nbsp;&nbsp;&nbsp;&nbsp;description "A .NET build and dependency manager"
&nbsp;&nbsp;&nbsp;&nbsp;get_from svn("http://scotaltdotnet.googlecode.com/svn/trunk/")
&nbsp;&nbsp;&nbsp;&nbsp;build_with msbuild, buildfile("src/horn.sln"), FrameworkVersion35
&nbsp;&nbsp;&nbsp;&nbsp;output "Output"
&nbsp;&nbsp;&nbsp;&nbsp;shared_library "."
</div>
If we rexamine the method signature of the install meta-method code:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">[<span style="color: #2b91af;">Meta</span>]
<span style="color: blue;">public</span> <span style="color: blue;">static</span> <span style="color: #2b91af;">Expression</span> install(<span style="color: #2b91af;">ReferenceExpression</span> expression, <span style="color: #2b91af;">BlockExpression</span> action)</pre>
</div>
The the <strong><i>horn</i></strong> part of the <strong><i>install horn:</i></strong> expression is passed to the meta-method as a ReferenceExpression type.  A ReferenceExpression type can be simply thought of as a <strong><i>token</i></strong> or block of text that is passed to the meta-method as an argument.

The anonymous method block is passed to the meta-method as a BlockExpression type.

Let us further examine the method body of the <strong><i>install</i></strong> meta-method:
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> installName = <span style="color: blue;">new</span> <span style="color: #2b91af;">StringLiteralExpression</span>(expression.Name);
&nbsp;
&nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">MethodInvocationExpression</span>(
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">new</span> <span style="color: #2b91af;">ReferenceExpression</span>(<span style="color: #a31515;">"GetInstallerMeta"</span>),
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; installName,
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; action
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; );
</div>
I Will reiterate once more that the install meta-method is called at compile time.  The meta-method takes an AST node and returns an AST node.  In the code above we are creating the result of calling the meta-method that will replace the AST that was passed to it.  In the above code, we are creating what is known as a MethodInvocationExpression that is creating a call to an instance method of the BooConfigReader class called GetInstallerName and the arguments that will be passed to it.

To sum up, the compiler replaces the <strong>install horn:</strong> expression with the following call to an instance of the BooConfigReader class <strong><i>GetInstallerMeta("horn", action);</i></strong>.

The <strong><i>GetInstallerMeta</i></strong> method is listed below for completeness.
<div style="font-family: Courier New; font-size: 11pt; color: black; background: white;">
<pre style="margin: 0px;"><span style="color: blue;">public</span> <span style="color: blue;">void</span> GetInstallerMeta(<span style="color: blue;">string</span> installName, <span style="color: #2b91af;">Action</span> installDelegate)
{
&nbsp;&nbsp;&nbsp; InstallName = installName;
&nbsp;
&nbsp;&nbsp;&nbsp; installDelegate();
}</pre>
</div>
The same result can be achieved by defining the same meta-method in boo:
<div style="font-family: Courier New; color: black; background: white;">
<pre style="margin: 0px;">abstract class BooConfigReader(IQuackFu): 
&nbsp;&nbsp;&nbsp;&nbsp;callable Action()
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;[Meta]
&nbsp;&nbsp;&nbsp;&nbsp;static def install(expression as ReferenceExpression, action as Expression):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = StringLiteralExpression(expression.Name)
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.GetInstallerMeta($name, $action)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|]	                
</div>
The return statement of the install method introduces a concept that makes boo more suited to writing code for compiler manipulation.  This strange expression creation is what is known as <strong><i>quasi quotation</i></strong>.

<strong><i>quasi quotation</i></strong> is only accessible through boo and you will not to recreate this experience in any other .NET language.

