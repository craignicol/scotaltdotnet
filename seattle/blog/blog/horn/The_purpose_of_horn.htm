In my previous <a href="http://thesoftwaresimpleton.blogspot.com/2009/04/decision-to-use-booas-horn-internal-dsl.html" target="_blank">post</a>, I stated that we had chosen <a href="http://boo.codehaus.org/" target="_blank">boo</a> as the host language of our internal Dsl.

What I omitted to mention was the purpose of the Horn Dsl. I now run the risk of losing whatever interest that the readers (if there are indeed any) may have by <strong>still</strong> not mentioning the Dsl but instead mentioning what purpose it is supposed to serve. I feel I must further waiver from the technical details in order to give proper context to the Dsl's reason to exist.

As I mentioned in the <a href="http://thesoftwaresimpleton.blogspot.com/2009/04/horn-package-manager-introduction.html" target="_blank">introduction</a>, <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> is based on the <a href="http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=2&amp;chap=1" target="_blank">gentoo portage</a> package manager. At the heart of both portage and indeed <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> is the metaphor of the package tree. The package tree is conceptually a tree that contains leaves of package build instructions. In reality it is a directory structure that contains Dsl instance files of package build instructions. Below is how the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> package tree looks at this time of writing.
<div><div>
<a href="http://4.bp.blogspot.com/_9M1wqOsISYo/SeC-WKxR-fI/AAAAAAAAAA8/87Gx8A_gqSo/s1600-h/tree.jpg"><img id="BLOGGER_PHOTO_ID_5323464047609379314" style="WIDTH: 139px; CURSOR: hand; HEIGHT: 179px" alt="" src="http://4.bp.blogspot.com/_9M1wqOsISYo/SeC-WKxR-fI/AAAAAAAAAA8/87Gx8A_gqSo/s200/tree.jpg" border="0" /></a> </div><div>
If you examine the image above, you can see that we have one top level node that is rather unimaginatively named <strong><i>package_tree</i></strong>. Below the root package_tree node are child nodes that represent package categories like ORM's, IOC's, loggers etc. The rational being that the we can use these next level nodes as search criteria to list all the object relational mappers for example that <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> could install. Contained in each of the category nodes are the individual package nodes like Nhiberate. In the example above you can see that <a href="http://www.hibernate.org/343.html" target="_blank">Nhibernate</a> is rightly positioned under a category parent node named orm. Contained within the indiviual Nhiberante package node is one build file named nhibernate.boo which contains the build metadata needed to install not only <a href="http://www.hibernate.org/343.html" target="_blank">Nhibernate</a> but any dependencies that are specified in the build file. The observant amongst you will notice that the package tree is persisted and retrieved from a <a href="http://subversion.tigris.org/" target="_blank">subversion</a> repository.

The package tree can be thought of a database of packages and their build instructions. When a user enters a command into the command prompt like the one below:

<a href="http://2.bp.blogspot.com/_9M1wqOsISYo/SeC_FrxZk7I/AAAAAAAAABM/rrshkHMn0Vk/s1600-h/cmd.jpg"><img id="BLOGGER_PHOTO_ID_5323464863922099122" style="WIDTH: 200px; CURSOR: hand; HEIGHT: 27px" alt="" src="http://2.bp.blogspot.com/_9M1wqOsISYo/SeC_FrxZk7I/AAAAAAAAABM/rrshkHMn0Vk/s200/cmd.jpg" border="0" /></a>

the <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> software system will search through the package tree to try and find a node named the same as the value of the <strong>-install</strong> switch which in this case is <a href="http://www.hibernate.org/343.html" target="_blank">Nhibernate</a>. Upon finding the correct node, <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> will then parse the contents of the build file which in this case is nhbiernate.boo into an <a href="http://martinfowler.com/dslwip/SemanticModel.html"><strong>semantic model</strong></a> or domain model that will be persisted in memory for the duration of the installation and more importantly contain all the information required to build and install the requested package.  <a target="_blank" href="http://martinfowler.com/">Martin Fowler</a> called the domain model in this context the <a href="http://martinfowler.com/dslwip/SemanticModel.html"><strong>semantic model</strong></a>.  In this article he states that from the domain model's point of view the DSL is just a fancy alternative way of creating it's objects and hooking them together.

</div><div>Below is the <a href="http://martinfowler.com/dslwip/SemanticModel.html"><strong>semantic model</strong></a> the Dsl describes:
<a target="_blank" href="http://2.bp.blogspot.com/_9M1wqOsISYo/SeDAHJxnjOI/AAAAAAAAABc/mXN-roZQ_-M/s1600-h/model.jpg"><img id="BLOGGER_PHOTO_ID_5323465988667575522" style="WIDTH: 200px; CURSOR: hand; HEIGHT: 106px" alt="" src="http://2.bp.blogspot.com/_9M1wqOsISYo/SeDAHJxnjOI/AAAAAAAAABc/mXN-roZQ_-M/s200/model.jpg" border="0" /><br/><strong>Click To Enlarge</strong></a></div>
The Dsl describes a <strong>BuildMetaData</strong> object that contains a <strong>SourceControl</strong> object and a <strong>BuildEngine</strong> object.

<a target="_blank" href="http://2.bp.blogspot.com/_9M1wqOsISYo/SeDBHmdtjRI/AAAAAAAAAB0/Kp1HuHiz3PQ/s1600-h/sourcecontrol.jpg"><img id="BLOGGER_PHOTO_ID_5323467095880338706" style="FLOAT: left; MARGIN: 0px 10px 10px 0px; WIDTH: 84px; CURSOR: hand; HEIGHT: 200px" alt="" src="http://2.bp.blogspot.com/_9M1wqOsISYo/SeDBHmdtjRI/AAAAAAAAAB0/Kp1HuHiz3PQ/s200/sourcecontrol.jpg" border="0" /></a>Typically, the source code for a particular package will be retrieved from a source control management system. This has been modelled as a <strong>SourceControl</strong> abstract class with particular implementations derived with their own specific implementation details. We currently have support for <a href="http://subversion.tigris.org/" target="_blank">subversion</a> only.</div>

Once we have exported the source code to the client's file system, the next logical <a target="_blank" href="http://2.bp.blogspot.com/_9M1wqOsISYo/SeDBc0nAe-I/AAAAAAAAAB8/YrIe2Iw9uiY/s1600-h/buildtool.jpg"><img id="BLOGGER_PHOTO_ID_5323467460454677474" style="FLOAT: right; MARGIN: 0px 0px 10px 10px; WIDTH: 200px; CURSOR: hand; HEIGHT: 74px" alt="" src="http://2.bp.blogspot.com/_9M1wqOsISYo/SeDBc0nAe-I/AAAAAAAAAB8/YrIe2Iw9uiY/s200/buildtool.jpg" border="0" /></a>step in the workflow is to build the source code. Horn has the concept of a <strong>BuildEngine</strong> object which is charged with building the source code. The Dsl has as part of it's definition a directive that tells <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> which <strong>BuildTool</strong> to build the source from. Currently we have 3 <strong>BuildTool</strong> implementations, <a href="http://nant.sourceforge.net/" target="_blank">Nant</a>, <a href="http://msdn.microsoft.com/en-us/library/wea2sca5.aspx" target="_blank">msbuild</a> and <a href="http://rake.rubyforge.org/" target="_blank">rake</a>. In most cases, the build of an open source system is complex and contrived. Typically the source code will contain a build script which orchestrates this complicated build process. We need to utilise these existing build scripts which in the .NET space are more times than not defined in <a href="http://nant.sourceforge.net/" target="_blank">Nant</a>. The MSBuild build tool will generally work with single components.

Once we have constructed this <a href="http://martinfowler.com/dslwip/SemanticModel.html"><strong>semantic model</strong></a> filled with the values in the DSL then <a href="http://code.google.com/p/scotaltdotnet/" target="_blank">horn</a> can build and install the requested package.

In the next <a target="_blank" href="http://thesoftwaresimpleton.blogspot.com/2009/04/parsing-horn-dsl.html">post</a> I will finally get to the <a href="http://boo.codehaus.org/" target="_blank">boo</a> DSL.  I will explain how horn loads specific instances of the Dsl into memory and parses it's contents into the semantic model with the help of a well known rhino.

If any of this is of interest to you then please join the <a href="http://groups.google.co.uk/group/horn-development?hl=en" target="_blank">Horn user group</a> for updates or check out the source <a href="http://code.google.com/p/scotaltdotnet/">here</a>.

